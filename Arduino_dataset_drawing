#include <SimplyAtomic.h>

#define MAX_POINTS 5000
#define CONTROL_INTERVAL_US 2000      // 2 ms control step
// #define REF_INTERVAL_US 5000         // 5 ms new reference position
#define LOG_INTERVAL 15               // log every Nth control step
#define MAX_LOGS 2500                 // how many log samples to keep

// ----- Motor pins -----
#define ENCA_1 0
#define ENCB_1 1
#define PWM_pin_1 2
#define IN1_1 3
#define IN2_1 4

#define ENCA_2 6
#define ENCB_2 7
#define PWM_pin_2 8
#define IN1_2 9
#define IN2_2 10

// ----- Encoder variables -----
volatile int posi_1 = 0, posi_2 = 0;

// ----- PID tuning -----
// --- EDIT: Created separate PID gains for each motor ---
// float k_p = 8, k_d = 0.5, k_i = 50; // Original global gains
float counts_per_rotation = 2100.0;

// PID gains for Motor 1
float k_p_1 = 8.0, k_d_1 = 0.8, k_i_1 = 50.0;

// PID gains for Motor 2
float k_p_2 = 8.0, k_d_2 = 0.8, k_i_2 = 50.0;
// --- END EDIT ---


// ----- Working vars -----
int pos_1 = 0, pos_2 = 0;
float e_1 = 0, e_2 = 0, e_prev_1 = 0, e_prev_2 = 0, sum_e_1 = 0, sum_e_2 = 0;
float u_1 = 0, u_2 = 0;
int u_amplitude_1 = 0, u_amplitude_2 = 0, u_sign_1 = 0, u_sign_2 = 0;
float ref_1 = 0, ref_2 = 0;
float uf_prev_1 = 0, uf_prev_2 = 0;
float alpha_u = 0.9;

float u_p_2;
float u_d_2;
float u_i_2;

unsigned long loop_prev = 0;
int loop_counter = 0;

// ----- Path data -----
int target_1[MAX_POINTS];
int target_2[MAX_POINTS];
int total_points = 0;
int current_index = 0;
bool path_loaded = false;
bool back_to_start = false;

// ----- RAM log buffer -----
struct LogEntry {
  int step;
  float e_1, e_2;
  float ref1, ref2;
  float uf_prev_1, uf_prev_2;
  float u_p_2, u_d_2, u_i_2;
};
LogEntry logs[MAX_LOGS];
int log_count = 0;

// =========================================================
// ======================== SETUP ===========================
// =========================================================
void setup() {
  Serial.begin(230400);

  pinMode(ENCA_1, INPUT);
  pinMode(ENCB_1, INPUT);
  pinMode(ENCA_2, INPUT);
  pinMode(ENCB_2, INPUT);
  attachInterrupt(digitalPinToInterrupt(ENCA_1), readEncoder_1, RISING);
  attachInterrupt(digitalPinToInterrupt(ENCA_2), readEncoder_2, RISING);

  pinMode(PWM_pin_1, OUTPUT);
  pinMode(IN1_1, OUTPUT);
  pinMode(IN2_1, OUTPUT);
  pinMode(PWM_pin_2, OUTPUT);
  pinMode(IN1_2, OUTPUT);
  pinMode(IN2_2, OUTPUT);

  Serial.println("Pico ready. Awaiting START message...");
}

// =========================================================
// ======================== MAIN LOOP =======================
// =========================================================
void loop() {
  if (!path_loaded) {
    receivePath();
    return;
  }

  // --- Step 2: Run control loop at fixed 5 ms ---
  unsigned long now = micros();
  if (now - loop_prev >= CONTROL_INTERVAL_US) {
    loop_prev += CONTROL_INTERVAL_US;

    ATOMIC() {
      pos_1 = posi_1;
      pos_2 = posi_2;
    }

    // --- Update reference only every REF_INTERVAL loops ---
    static unsigned long ref_timer = 0;
    const unsigned long REF_INTERVAL_US = 5000;  // 5 ms between new points
    if (now - ref_timer >= REF_INTERVAL_US && current_index < total_points) {
      ref_timer = now;
      ref_1 = target_1[current_index];
      ref_2 = target_2[current_index];
      if (back_to_start == false) {
        current_index++;
      }
    }

    // --- PID Control ---
    
    // Motor 1
    e_1 = ref_1 - pos_1;

    if  ((e_1 <= (255/k_p_1)) && (e_1 >= (-255/k_p_1))){
      sum_e_1 += e_1 * CONTROL_INTERVAL_US / 1e6;
    } else {
      sum_e_1 = 0.0;
    }
    
    // --- EDIT: Using Motor 1's PID gains ---
    u_1 = k_p_1 * e_1 + k_d_1 * (e_1 - e_prev_1) * 1e6 / CONTROL_INTERVAL_US + k_i_1 * sum_e_1;
    // --- END EDIT ---
    
    float uf_1 = alpha_u * uf_prev_1 + (1.0 - alpha_u) * u_1;
    e_prev_1 = e_1;
    uf_1 = constrain(uf_1, -255, 255);
    uf_prev_1 = uf_1;

    // Motor 2
    e_2 = ref_2 - pos_2;

    if  ((e_2 <= (255/k_p_2)) && (e_2 >= (-255/k_p_2))){
      sum_e_2 += e_2 * CONTROL_INTERVAL_US / 1e6;
    } else {
      sum_e_2 = 0.0;
    }


    u_p_2 = k_p_2 * e_2;
    u_d_2 = k_d_2 * (e_2 - e_prev_2) * 1e6 / CONTROL_INTERVAL_US;
    u_i_2 = k_i_2 * sum_e_2;
    
    // --- EDIT: Using Motor 2's PID gains ---
    u_2 = k_p_2 * e_2 + k_d_2 * (e_2 - e_prev_2) * 1e6 / CONTROL_INTERVAL_US + k_i_2 * sum_e_2;
    // --- END EDIT ---


    float uf_2 = alpha_u * uf_prev_2 + (1.0 - alpha_u) * u_2;

    e_prev_2 = e_2;
    uf_2 = constrain(uf_2, -255, 255);
    uf_prev_2 = uf_2;

    setMotor((uf_1 > 0) - (uf_1 < 0), abs(uf_1), PWM_pin_1, IN1_1, IN2_1);
    setMotor((uf_2 > 0) - (uf_2 < 0), abs(uf_2), PWM_pin_2, IN1_2, IN2_2);

    // --- Log every N control loops ---
    loop_counter++;
    if ((loop_counter % LOG_INTERVAL) == 0 && log_count < MAX_LOGS) {
      logs[log_count++] = {current_index, e_1, e_2, ref_1, ref_2, uf_prev_1, uf_prev_2, u_p_2, u_d_2, u_i_2};
    }

    // --- End condition ---
    if (current_index >= total_points && abs(e_1) < 5 && abs(e_2) < 5) {
      back_to_start = true;
//      setMotor(0, 0, PWM_pin_1, IN1_1, IN2_1);
//      setMotor(0, 0, PWM_pin_2, IN1_2, IN2_2);
      if (e_1 == 0){
        setMotor(0, 0, PWM_pin_1, IN1_1, IN2_1);
      }
      if (e_2 == 0){
        setMotor(0, 0, PWM_pin_2, IN1_2, IN2_2);
      }
      if (e_1 == 0 && e_2 == 0){
        current_index = 0;
        dumpLogs();
        resetLog();
        path_loaded = false;
        
      }

      return;
    }
  }
}

// =========================================================
// =================== RECEIVE PATH DATA ====================
// =========================================================
void receivePath() {
  static bool receiving = false;
  bool back_to_start = false;
  static int points_expected = 0;
  static int points_received = 0;

  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    if (line.length() == 0) return;

    // ---- START <N> ----
    if (line.startsWith("START")) {
      points_expected = line.substring(6).toInt();
      points_received = 0;

      if (points_expected <= 0 || points_expected > MAX_POINTS) {
        Serial.print("ERR INVALID_COUNT ");
        Serial.println(points_expected);
        return;
      }
      receiving = true;
      Serial.print("READY_FOR_DATA ");
      Serial.println(points_expected);
      return;
    }

    // ---- END ----
    if (line == "END") {
      receiving = false;
      total_points = points_received;
      path_loaded = true;
      current_index = 0;
      Serial.print("Path loaded. Points received=");
      Serial.println(points_received);
      return;
    }

    // ---- Data lines ----
    if (receiving && points_received < MAX_POINTS) {
      int spaceIdx = line.indexOf(' ');
      if (spaceIdx > 0) {
        target_1[points_received] = line.substring(0, spaceIdx).toInt();
        target_2[points_received] = line.substring(spaceIdx + 1).toInt();
        points_received++;

        if ((points_received % 500) == 0) {
          Serial.print("RECV ");
          Serial.println(points_received);
        }
      }
    }
  }
}



// =========================================================
// ====================== UTILITIES =========================
// =========================================================
void stopMotors() {
  setMotor(0, 0, PWM_pin_1, IN1_1, IN2_1);
  setMotor(0, 0, PWM_pin_2, IN1_2, IN2_2);
}

void setMotor(int dir, int pwmVal, int pwm_pin, int in1, int in2) {
  analogWrite(pwm_pin, pwmVal);
  if (dir == 1) {
    digitalWrite(in1, HIGH);
    digitalWrite(in2, LOW);
  } else if (dir == -1) {
    digitalWrite(in1, LOW);
    digitalWrite(in2, HIGH);
  } else {
    digitalWrite(in1, LOW);
    digitalWrite(in2, LOW);
  }
}

// Dump log buffer after motion completes
void dumpLogs() {
  Serial.println("--- BEGIN LOG ---");
  for (int i = 0; i < log_count; i++) {
    Serial.print(logs[i].step);
    Serial.print(',');
    Serial.print(logs[i].ref1);
    Serial.print(',');
    Serial.print(logs[i].e_1);
    Serial.print(',');
    Serial.print(logs[i].ref2);
    Serial.print(',');
    Serial.print(logs[i].e_2);
    Serial.print(',');
    Serial.print(logs[i].uf_prev_1);
    Serial.print(',');
    Serial.print(logs[i].uf_prev_2);
    Serial.print(',');
    Serial.print(logs[i].u_p_2);
    Serial.print(',');
    Serial.print(logs[i].u_d_2);
    Serial.print(',');
    Serial.println(logs[i].u_i_2);
  }
  Serial.println("--- END LOG ---");
}

// Completely clear the log buffer
void resetLog() {
  // Optionally zero all entries
  for (int i = 0; i < MAX_LOGS; i++) {
    logs[i] = {0, 0, 0, 0, 0, 0, 0};
  }

  // Reset log counter
  log_count = 0;
}

// ---- Encoder ISRs ----
void readEncoder_1() {
  int b = digitalRead(ENCB_1);
  posi_1 += (b > 0) ? 1 : -1;
}
void readEncoder_2() {
  int b = digitalRead(ENCB_2);
  posi_2 += (b > 0) ? 1 : -1;
}
