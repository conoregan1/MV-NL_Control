#include <SimplyAtomic.h>

#define MAX_POINTS 5000
#define CONTROL_INTERVAL_US 2000     // 2 ms control step
#define LOG_INTERVAL 10              // log every Nth control step
#define MAX_LOGS 2500              // how many log samples to keep

// --- NEW: Settle logic ---
#define SETTLE_ERROR_THRESHOLD 1     // How many counts of error is "settled"
#define SETTLE_DURATION_US 500000  // 500ms hold time to be "settled"

// ----- Motor pins -----
#define ENCA_1 0
#define ENCB_1 1
#define PWM_pin_1 2
#define IN1_1 3
#define IN2_1 4

#define ENCA_2 6
#define ENCB_2 7
#define PWM_pin_2 8
#define IN1_2 9
#define IN2_2 10

// ----- Encoder variables -----
volatile int posi_1 = 0, posi_2 = 0;

// ----- PID tuning -----
float k_p_1 = 18.0, k_d_1 = 0.8, k_i_1 = 80.0;
float k_p_2 = 18.0, k_d_2 = 0.8, k_i_2 = 80.0;


// ----- Working vars -----
int pos_1 = 0, pos_2 = 0;
float e_1 = 0, e_2 = 0, e_prev_1 = 0, e_prev_2 = 0, sum_e_1 = 0, sum_e_2 = 0;
float u_1 = 0, u_2 = 0;
float ref_1 = 0, ref_2 = 0;
float uf_prev_1 = 0, uf_prev_2 = 0;
float alpha_u = 0.8;

float u_p_2;
float u_d_2;
float u_i_2;

unsigned long loop_prev = micros();
unsigned long ref_timer = micros();
int loop_counter = 0;

// ----- Path data -----
float target_1[MAX_POINTS];
float target_2[MAX_POINTS];
int total_points = 0;
int current_index = 0;

// ----- State Machine Vars -----
bool path_loaded = false;     // True when path is in memory
bool path_finished = false;   // True when index >= total_points
bool path_settled = false;    // True after holding final pos for SETTLE_DURATION
unsigned long settle_start_time = 0; // Timer for holding

// ----- RAM log buffer -----
struct LogEntry {
  int step;
  float e_1, e_2;
  float ref1, ref2;
  float uf_prev_1, uf_prev_2;
  float u_p_2, u_d_2, u_i_2;
};
LogEntry logs[MAX_LOGS];
int log_count = 0;

// =========================================================
// ======================== SETUP ===========================
// =========================================================
void setup() {
  Serial.begin(230400);

  pinMode(ENCA_1, INPUT);
  pinMode(ENCB_1, INPUT);
  pinMode(ENCA_2, INPUT);
  pinMode(ENCB_2, INPUT);
  attachInterrupt(digitalPinToInterrupt(ENCA_1), readEncoder_1, RISING);
  attachInterrupt(digitalPinToInterrupt(ENCA_2), readEncoder_2, RISING);

  pinMode(PWM_pin_1, OUTPUT);
  pinMode(IN1_1, OUTPUT);
  pinMode(IN2_1, OUTPUT);
  pinMode(PWM_pin_2, OUTPUT);
  pinMode(IN1_2, OUTPUT);
  pinMode(IN2_2, OUTPUT);

  // --- NEW ---
  // Reset all state variables on boot
  resetState();
  stopMotors();

  Serial.println("Pico ready. Awaiting START message...");
}

// =========================================================
// ======================== MAIN LOOP =======================
// =========================================================
void loop() {
  if (!path_loaded) {
    receivePath();
    return; // Stay in receive mode
  }

  // --- Control loop always runs if path is loaded ---
  unsigned long now = micros();
  if (now - loop_prev >= CONTROL_INTERVAL_US) {
    loop_prev = now;

    ATOMIC() {
      pos_1 = posi_1;
      pos_2 = posi_2;
    }

    // --- Path Following Logic ---
    // Only update reference if the path is still running
    const unsigned long REF_INTERVAL_US = 2000;
    if (!path_finished && (now - ref_timer >= REF_INTERVAL_US)) {
      ref_timer = now;
      if (current_index < total_points) {
        ref_1 = target_1[current_index];
        ref_2 = target_2[current_index];
        current_index++;
      }
      if (current_index >= total_points) {
        path_finished = true; // Path points are done. Now we HOLD.
      }
    }

    // --- PID Control (Always runs) ---
    // This will follow the path, and then hold the last position
    
    // Motor 1
    e_1 = ref_1 - pos_1;
    if  (abs(e_1) < (255.0 / k_p_1)) { // Anti-windup
      sum_e_1 += e_1 * CONTROL_INTERVAL_US / 1e6;
    } else {
      sum_e_1 = 0.0;
    }
    u_1 = k_p_1 * e_1 + k_d_1 * (e_1 - e_prev_1) * 1e6 / CONTROL_INTERVAL_US + k_i_1 * sum_e_1;
    float uf_1 = alpha_u * uf_prev_1 + (1.0 - alpha_u) * u_1;
    e_prev_1 = e_1;
    uf_1 = constrain(uf_1, -255, 255);
    uf_prev_1 = uf_1;

    // Motor 2
    e_2 = ref_2 - pos_2;
    if (abs(e_2) < (255.0 / k_p_2)) { // Anti-windup
      sum_e_2 += e_2 * CONTROL_INTERVAL_US / 1e6;
    } else {
      sum_e_2 = 0.0;
    }
    u_p_2 = k_p_2 * e_2;
    u_d_2 = k_d_2 * (e_2 - e_prev_2) * 1e6 / CONTROL_INTERVAL_US;
    u_i_2 = k_i_2 * sum_e_2;
    u_2 = u_p_2 + u_d_2 + u_i_2;
    float uf_2 = alpha_u * uf_prev_2 + (1.0 - alpha_u) * u_2;
    e_prev_2 = e_2;
    uf_2 = constrain(uf_2, -255, 255);
    uf_prev_2 = uf_2;

    // --- Logging ---
    loop_counter++;
    if ((loop_counter % LOG_INTERVAL) == 0 && log_count < MAX_LOGS) {
      logs[log_count++] = {current_index, e_1, e_2, ref_1, ref_2, uf_prev_1, uf_prev_2, u_p_2, u_d_2, u_i_2};
    }

    // --- NEW: End condition logic ---
    // This block replaces your old end-of-path logic
    if (path_finished && !path_settled) {
      // Path is done, PID is holding. Check if we are settled.
      if (abs(e_1) < SETTLE_ERROR_THRESHOLD && abs(e_2) < SETTLE_ERROR_THRESHOLD) {
        
        // Error is low. Start/check the settle timer.
        if (settle_start_time == 0) {
          settle_start_time = micros(); // Start the timer
        }

        // Check if we've *stayed* settled for the full duration
        if (micros() - settle_start_time >= SETTLE_DURATION_US) {
          // --- SUCCESS! We are done and settled ---
          path_settled = true; // 1. Lock this state
          dumpLogs();          // 2. Send data
          stopMotors();        // 3. Turn off motors
          resetState();        // 4. RESET ALL CONTROLLER MEMORY
          path_loaded = false; // 5. Go back to waiting for a path
          return;              // 6. Exit control loop
        }
        
      } else {
        // We are not settled (or we overshot and error is high again).
        // Reset the settle timer. We must be low-error *continuously*.
        settle_start_time = 0;
      }
    }
    // --- End of new logic ---

    // Drive motors (always, unless we just reset)
    setMotor((uf_1 > 0) - (uf_1 < 0), abs(uf_1), PWM_pin_1, IN1_1, IN2_1);
    setMotor((uf_2 > 0) - (uf_2 < 0), abs(uf_2), PWM_pin_2, IN1_2, IN2_2);
  }
}

// =========================================================
// =================== RECEIVE PATH DATA ====================
// =========================================================
void receivePath() {
  static bool receiving = false;
  static int points_expected = 0;
  static int points_received = 0;

  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    if (line.length() == 0) return;

    if (line.startsWith("START")) {
      // --- MODIFIED ---
      // We are starting a new path. Reset *everything* to a clean slate.
      // This is the main fix for Problem 2 (Rerunning).
      resetState();
      stopMotors();
      // --- END MODIFIED ---
      
      points_expected = line.substring(6).toInt();
      points_received = 0;

      if (points_expected <= 0 || points_expected > MAX_POINTS) {
        Serial.print("ERR INVALID_COUNT ");
        Serial.println(points_expected);
        return;
      }
      receiving = true;
      Serial.print("READY_FOR_DATA ");
      Serial.println(points_expected);
      return;
    }

    if (line == "END") {
      receiving = false;
      total_points = points_received;
      
      if (total_points > 0) {
        path_loaded = true; // <<< This is what starts the loop()
        
        // --- MODIFIED ---
        // Pre-load the first point as the target.
        // resetState() already set encoders to 0, which matches
        // the Python script's "home" position.
        ref_1 = target_1[0];
        ref_2 = target_2[0];
        // --- END MODIFIED ---
        
        Serial.print("Path loaded. Points received=");
        Serial.println(points_received);
      } else {
        Serial.println("ERR NO_POINTS_RECV");
      }
      return;
    }

    // ---- Data lines ----
    if (receiving && points_received < MAX_POINTS) {
      int spaceIdx = line.indexOf(' ');
      if (spaceIdx > 0) {
        target_1[points_received] = line.substring(0, spaceIdx).toInt();
        target_2[points_received] = line.substring(spaceIdx + 1).toInt();
        points_received++;

        if ((points_received % 500) == 0) {
          Serial.print("RECV ");
          Serial.println(points_received);
        }
      }
    }
  }
}



// =========================================================
// ====================== UTILITIES =========================
// =========================================================

// --- NEW FUNCTION ---
// This is the fix for Problem 2 (Rerunning)
// It resets all working variables to a clean state.
void resetState() {
  // Reset PID controller state
  e_1 = 0; e_prev_1 = 0; sum_e_1 = 0;
  e_2 = 0; e_prev_2 = 0; sum_e_2 = 0;
  u_1 = 0; u_2 = 0;
  uf_prev_1 = 0; uf_prev_2 = 0;

  // Reset position references
  ref_1 = 0; ref_2 = 0;
  
  // Reset encoder counters
  ATOMIC() {
    posi_1 = 0;
    posi_2 = 0;
  }
  pos_1 = 0;
  pos_2 = 0;

  // Reset path/loop counters
  current_index = 0;
  total_points = 0;
  loop_counter = 0;
  
  // Reset state machine flags
  path_loaded = false; // Will be set true by receivePath()
  path_finished = false;
  path_settled = false;
  settle_start_time = 0;

  // Reset log
  resetLog();
}
// --- END NEW FUNCTION ---

void stopMotors() {
  setMotor(0, 0, PWM_pin_1, IN1_1, IN2_1);
  setMotor(0, 0, PWM_pin_2, IN1_2, IN2_2);
}

void setMotor(int dir, int pwmVal, int pwm_pin, int in1, int in2) {
  analogWrite(pwm_pin, pwmVal);
  if (dir == 1) {
    digitalWrite(in1, HIGH);
    digitalWrite(in2, LOW);
  } else if (dir == -1) {
    digitalWrite(in1, LOW);
    digitalWrite(in2, HIGH);
  } else {
    digitalWrite(in1, LOW);
    digitalWrite(in2, LOW);
  }
}

// Dump log buffer after motion completes
void dumpLogs() {
  Serial.println("--- BEGIN LOG ---");
  for (int i = 0; i < log_count; i++) {
    Serial.print(logs[i].step);
    Serial.print(',');
    Serial.print(logs[i].ref1);
    Serial.print(',');
    Serial.print(logs[i].e_1);
    Serial.print(',');
    Serial.print(logs[i].ref2);
    Serial.print(',');
    Serial.print(logs[i].e_2);
    Serial.print(',');
    Serial.print(logs[i].uf_prev_1);
    Serial.print(',');
    Serial.print(logs[i].uf_prev_2);
    Serial.print(',');
    Serial.print(logs[i].u_p_2);
    Serial.print(',');
    Serial.print(logs[i].u_d_2);
    Serial.print(',');
    Serial.println(logs[i].u_i_2);
  }
  Serial.println("--- END LOG ---");
}

// Completely clear the log buffer
void resetLog() {
  // Zero all entries
  for (int i = 0; i < MAX_LOGS; i++) {
    logs[i] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  }
  log_count = 0;
}

// ---- Encoder ISRs ----
void readEncoder_1() {
  int b = digitalRead(ENCB_1);
  posi_1 += (b > 0) ? 1 : -1;
}
void readEncoder_2() {
  int b = digitalRead(ENCB_2);
  posi_2 += (b > 0) ? 1 : -1;
}
