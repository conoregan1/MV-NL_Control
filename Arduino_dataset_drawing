#include <SimplyAtomic.h>

#define MAX_POINTS 5000  // adjust for your memory (e.g., 5000 points)
#define CONTROL_INTERVAL_US 2000

// Motor pins (unchanged)
#define ENCA_1 0
#define ENCB_1 1
#define PWM_pin_1 2
#define IN1_1 3
#define IN2_1 4

#define ENCA_2 6
#define ENCB_2 7
#define PWM_pin_2 8
#define IN1_2 9
#define IN2_2 10

volatile int posi_1 = 0, posi_2 = 0;

float k_p = 1.0, k_d = 0.1, k_i = 0.1;
float counts_per_rotation = 2100.0;

int pos_1 = 0, pos_2 = 0;
float e_1 = 0, e_2 = 0, e_prev_1 = 0, e_prev_2 = 0, sum_e_1 = 0, sum_e_2 = 0;
float u_1 = 0, u_2 = 0;
int u_amplitude_1 = 0, u_amplitude_2 = 0, u_sign_1 = 0, u_sign_2 = 0;

float ref_1 = 0, ref_2 = 0;

unsigned long loop_prev = 0;

// --- Buffers for received path ---
int target_1[MAX_POINTS];
int target_2[MAX_POINTS];
int total_points = 0;
int current_index = 0;
bool path_loaded = false;

void setup() {
  Serial.begin(230400);

  pinMode(ENCA_1, INPUT);
  pinMode(ENCB_1, INPUT);
  pinMode(ENCA_2, INPUT);
  pinMode(ENCB_2, INPUT);
  attachInterrupt(digitalPinToInterrupt(ENCA_1), readEncoder_1, RISING);
  attachInterrupt(digitalPinToInterrupt(ENCA_2), readEncoder_2, RISING);

  pinMode(PWM_pin_1, OUTPUT);
  pinMode(IN1_1, OUTPUT);
  pinMode(IN2_1, OUTPUT);
  pinMode(PWM_pin_2, OUTPUT);
  pinMode(IN1_2, OUTPUT);
  pinMode(IN2_2, OUTPUT);

  Serial.println("Pico ready. Awaiting START message...");
}

void loop() {
  // --- Step 1: Wait for path data if not loaded ---
  if (!path_loaded) {
    receivePath();
    return;
  }

  // --- Step 2: Run control loop at 2ms intervals ---
  unsigned long now = micros();
  if (now - loop_prev >= CONTROL_INTERVAL_US) {
    loop_prev = now;

    ATOMIC() {
      pos_1 = posi_1;
      pos_2 = posi_2;
    }

    if (current_index < total_points) {
      ref_1 = target_1[current_index];
      ref_2 = target_2[current_index];
      current_index++;
    } else {
      setMotor(0, 0, PWM_pin_1, IN1_1, IN2_1);
      setMotor(0, 0, PWM_pin_2, IN1_2, IN2_2);
      Serial.println("Path complete.");
      path_loaded = false;
      current_index = 0;
      return;
    }

    // --- PID for Motor 1 ---
    e_1 = ref_1 - pos_1;
    sum_e_1 += e_1 * CONTROL_INTERVAL_US / 1000000.0;
    u_1 = k_p * e_1 + k_d * (e_1 - e_prev_1) * 1000000.0 / CONTROL_INTERVAL_US + k_i * sum_e_1;
    e_prev_1 = e_1;
    u_1 = constrain(u_1, -255, 255);
    u_amplitude_1 = abs(u_1);
    u_sign_1 = (u_1 > 0) ? 1 : (u_1 < 0) ? -1 : 0;

    // --- PID for Motor 2 ---
    e_2 = ref_2 - pos_2;
    sum_e_2 += e_2 * CONTROL_INTERVAL_US / 1000000.0;
    u_2 = k_p * e_2 + k_d * (e_2 - e_prev_2) * 1000000.0 / CONTROL_INTERVAL_US + k_i * sum_e_2;
    e_prev_2 = e_2;
    u_2 = constrain(u_2, -255, 255);
    u_amplitude_2 = abs(u_2);
    u_sign_2 = (u_2 > 0) ? 1 : (u_2 < 0) ? -1 : 0;

    // --- Drive Motors ---
    setMotor(u_sign_1, u_amplitude_1, PWM_pin_1, IN1_1, IN2_1);
    setMotor(u_sign_2, u_amplitude_2, PWM_pin_2, IN1_2, IN2_2);

    // Optional: debug every Nth point
    if (current_index % 500 == 0) {
      Serial.print("Step ");
      Serial.print(current_index);
      Serial.print("/");
      Serial.print(total_points);
      Serial.print(" | M1 pos=");
      Serial.print(pos_1);
      Serial.print(" ref=");
      Serial.print(ref_1);
      Serial.print(" | M2 pos=");
      Serial.print(pos_2);
      Serial.print(" ref=");
      Serial.println(ref_2);
    }
  }
}

// --- Receive full dataset ---
void receivePath() {
  static bool receiving = false;
  static int points_expected = 0;
  static int points_received = 0;

  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();

    if (line.startsWith("START")) {
      points_expected = line.substring(6).toInt();
      points_received = 0;
      receiving = true;
      Serial.print("Receiving ");
      Serial.print(points_expected);
      Serial.println(" points...");
      return;
    }

    if (line == "END") {
      receiving = false;
      total_points = points_received;
      path_loaded = true;
      current_index = 0;
      Serial.println("Path loaded. Starting motion...");
      return;
    }

    if (receiving && points_received < MAX_POINTS) {
      int spaceIdx = line.indexOf(' ');
      if (spaceIdx > 0) {
        target_1[points_received] = line.substring(0, spaceIdx).toInt();
        target_2[points_received] = line.substring(spaceIdx + 1).toInt();
        points_received++;
      }
    }
  }
}

// --- Motor drive ---
void setMotor(int dir, int pwmVal, int pwm_pin, int in1, int in2) {
  analogWrite(pwm_pin, pwmVal);
  if (dir == 1) {
    digitalWrite(in1, HIGH);
    digitalWrite(in2, LOW);
  } else if (dir == -1) {
    digitalWrite(in1, LOW);
    digitalWrite(in2, HIGH);
  } else {
    digitalWrite(in1, LOW);
    digitalWrite(in2, LOW);
  }
}

// --- Encoder interrupts ---
void readEncoder_1() {
  int b = digitalRead(ENCB_1);
  posi_1 += (b > 0) ? 1 : -1;
}
void readEncoder_2() {
  int b = digitalRead(ENCB_2);
  posi_2 += (b > 0) ? 1 : -1;
}
